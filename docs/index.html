<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Documentation | LinkWell Nodes</title>
  <link rel="icon" type="image/x-icon" href="/media/favicon.ico">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <meta name="description" content="Description">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsify-themeable@0/dist/css/theme-simple.css">
  <!-- PrismJS theme -->
  <!-- <link rel="stylesheet" href="path/to/prismjs-theme.css"> -->
  <link rel="stylesheet" href="/media/styles.css">
</head>
<body>
  <div id="app"></div>
  <script>
    window.$docsify = {
      // logo: '/media/LinkWellLogo.png',
      coverpage: false,
      loadSidebar: true,
	  alias: {
            '/.*/_sidebar.md': '/_sidebar.md'
        },
      subMaxLevel: 1,
      sidebarDisplayLevel: 0,	// the default expansion of the sidebar
      name: 'Documentation',
      nameLink: '/',
      repo: 'https://github.com/LinkWellNodes',
      search: 'auto',
      routerMode: 'history',
      pagination: {
        crossChapter: true,
        crossChapterText: true
  	  },
  	  tabs: {
  	    theme: 'classic',
  	  	tabHeadings: true
  	  }
    }
    
  </script>
  <!-- Allow for iframe resizing despite being at a different subdomain: https://github.com/davidjbradshaw/iframe-resizer -->
  <script type="text/javascript" src="/media/iframeResizer.contentWindow.min.js"></script>
  <!-- Docsify v4 -->
  <script src="//cdn.jsdelivr.net/npm/docsify@4.13"></script>
  <!-- docsify-tabs plugin - (latest v1.x.x) -->
  <script src="https://cdn.jsdelivr.net/npm/docsify-tabs@1"></script>
  <!-- Copy to Clipboard Plugin - Latest v2.x.x -->
  <script src="//cdn.jsdelivr.net/npm/docsify-copy-code/dist/docsify-copy-code.min.js"></script> 
  <!-- Search Bar Plugin  -->
  <script src="//cdn.jsdelivr.net/npm/docsify/lib/plugins/search.min.js"></script>
  <!-- Pagination Plugin -->
  <script src="//cdn.jsdelivr.net/npm/docsify-pagination/dist/docsify-pagination.min.js"></script>
  <!-- JQuery library -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.4/jquery.min.js"></script>
  <!-- <script src="//cdn.jsdelivr.net/npm/docsify/lib/docsify.min.js"></script> Was creating a secondary search bar in the sidebar --> 
  <!-- Sidebar collapsing support -->
  <script src="//cdn.jsdelivr.net/npm/docsify-sidebar-collapse/dist/docsify-sidebar-collapse.min.js"></script>
  
<script>
$(function() {
	
	// Listen for page URL changes (doesn't detect PATH or PARAM changes though)
	const observeUrlChange = () => {
		let oldHref = document.location.href;
		const body = document.querySelector("body");
		const observer = new MutationObserver(mutations => {
			if (oldHref !== document.location.href) {
				oldHref = document.location.href;
				// Ensure we start at the top of the new page
				window.scroll({
					top:0,
					left:0
				});
				if ('parentIFrame' in window) {        // is this page loaded inside an iframe?
					//console.log("New iframe page loaded: " + window.location.hash);
					updateUrlInParentPage(null);
				}
			}
		});
		observer.observe(body, { childList: true, subtree: true });
	};
	window.onload = observeUrlChange;
	
	// Intercept all clicks on anchor links, and tell the parent document the Y coordinate to which to scroll (if this page is loaded inside of an iframe)
	$(document).on('click', '.anchor, .section-link, a', function(e) {
        if ('parentIFrame' in window) {		// is this page loaded inside an iframe? 
        	// Get the anchored element to which we'd like to scroll 
        	var anchorIdStr = $(this).blur().attr('href').split('?id=').pop();
        	if (!anchorIdStr.includes("/")) {
	            var anchor = $('#' + anchorIdStr);
	        	// Get the Y coordinate of the anchored element
	            var offset = Math.round(anchor.offset().top);
	            e.preventDefault();
	            // Send the Y coordinate of the anchored element to the parent webpage (ie, the page containing this iframe)
	            window.parentIFrame.sendMessage(offset);
	            // Send the anchor id tag to the parent webpage, so that it can update its URL
	            updateUrlInParentPage(anchorIdStr);
        	}
        }
    });
	
	// Receive all message events from the parent website
	var scrolledToParentAnchorAlready = false;
	window.addEventListener('message', function(event) {
		var msg;
		try {
			msg = JSON.parse(event.data);
		} catch (e) {
			msg = JSON.stringify(event.data);
		}
		// Receive all events from the parent regarding the anchor id toward which to scroll, and then do it
		//console.log("Message received from the parent: " + event.origin + " / " + msg);
		if (msg.parentAnchorId && !scrolledToParentAnchorAlready) {
	   		//console.log("Anchor received: " + msg.parentAnchorId);
   			$(document).ready(function(){
	   			// Get the anchored element to which we'd like to scroll
   				var anchor = $('#' + msg.parentAnchorId);
   				if (anchor.length) {	// check to ensure the anchor exists
	   	   			// Get the Y coordinate of the anchored element
	   	   			var offset = Math.round(anchor.offset().top);
   					//console.log("Posting anchor offset (Y:" + offset +")");
	   	   			// Send the Y coordinate of the anchored element to the parent webpage (ie, the page containing this iframe), so that it can scroll
	   	   			const loop1Id = setInterval(function () {	// perform this as a loop, as window.parentIframe takes a while to actually become available 
	   	   				if ('parentIFrame' in window) {
	   	   					scrolledToParentAnchorAlready = true;
							window.parentIFrame.sendMessage(offset);
							clearInterval(loop1Id);
	   	   				}
					}, 10);
   				} else {
   					//console.log("Invalid anchorId. Will re-try upon receiving the next message...");
   				}
   			});
		}
	});
});

var lastUpdateSent = {};
function updateUrlInParentPage(anchorId) {
    var path = window.location.pathname;
    if (!anchorId) {
    	anchorId = "";
    }
    if (path.length > 0) {
		var pageId = "";
	    if (path.charAt(0) == '#') {
	    	path = path.substring(1);    // remove the first char ('#')
	    }
	    if (path.includes("?id=")) {
	    	// (anchorId present)
			const pathArr = path.split("?id=");
			if (pathArr.length == 2) {
				pageId = pathArr[0];
				//anchorId = pathArr[1];
			} else {
				console.warn("Unexpected URL path format: " + path);
			}
	    } else {
	    	pageId = path;
	    	// (no anchorId present)
	    }
	    //console.log("pageId="+pageId);
	    //console.log("anchorId="+anchorId);
	    // Send the URL update to the parent page
	    const updToSend = {"urlChanged": {"pageId": pageId, "anchorId": anchorId}};
	    if (JSON.stringify(lastUpdateSent) == JSON.stringify(updToSend)) {
	    	//console.log("Discarding repetitive update of parent URL"); 
	    } else {
	    	//console.log("Sending URL update to parent | pageId: " + pageId + " | anchorId: " + anchorId);
		    lastUpdateSent = updToSend;
		    window.parentIFrame.sendMessage(updToSend);
	    }
    } else {
    	console.warn("No URL path detected. Skipping updateUrlInParentPage()");
    }
}

<!-- Start Single Page Apps for GitHub Pages (https://github.com/rafgraph/spa-github-pages). We use this to allow for routerMode: 'history', so that Google can index all pages, while at the same time redirecting the resulting 404.html target that GitHub wants to send us to to the appropriate page  -->
<!-- SEO implications here: https://github.com/rafgraph/spa-github-pages#seo -->
// Single Page Apps for GitHub Pages
// MIT License
// https://github.com/rafgraph/spa-github-pages
// This script checks to see if a redirect is present in the query string,
// converts it back into the correct url and adds it to the
// browser's history using window.history.replaceState(...),
// which won't cause the browser to attempt to load the new url.
// When the single page app is loaded further down in this file,
// the correct url will be waiting in the browser's history for
// the single page app to route accordingly.
(function(l) {
  if (l.search[1] === '/' ) {
    var decoded = l.search.slice(1).split('&').map(function(s) { 
      return s.replace(/~and~/g, '&')
    }).join('?');
    window.history.replaceState(null, null,
        l.pathname.slice(0, -1) + decoded + l.hash
    );
  }
}(window.location))

</script>

</body>
</html>