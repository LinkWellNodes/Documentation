//SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import "@chainlink/contracts/src/v0.8/ChainlinkClient.sol";
import "@chainlink/contracts/src/v0.8/ConfirmedOwner.sol";

/**
 * Request testnet LINK and ETH here: https://faucets.chain.link/
 * Find information on LINK Token Contracts and get the latest ETH and LINK faucets here: https://docs.chain.link/docs/link-token-contracts/
 */

/**
 * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
 */

contract LinkWellVRNInt256ArrConsumerContractExample is ChainlinkClient, ConfirmedOwner {
    using Chainlink for Chainlink.Request;

	address private oracleAddress;
    bytes32 private jobId;
    uint256 private fee;

    struct VRNRequest {
        int256 minVal;
        int256 maxVal;
        bytes32 hash;
        int256[] randomNumbers;
        bool requested;
    }

    mapping(bytes32 => VRNRequest) public requestMap;
    mapping(bytes32 => bytes32) public seedMap;

    constructor() ConfirmedOwner(msg.sender) {
        _setChainlinkToken(0x404460C6A5EdE2D891e8297795264fDe62ADBB75);
        setOracleAddress(<oracle address>);
        setJobId("6e8063b1ced54163aadddc5237c6d04e");
        setFeeInHundredthsOfLink(0);     // 0 LINK
    }

    /**
     * Send a request to the Chainlink oracle to retrieve multiple deterministic 'random' integers within the given range (inclusive).
     *  minVal = The lower limit of the possible random number value (inclusive)
     *  maxVal = The upper limit of the possible random number value (inclusive)
     *  quantity = The number of random numbers to retrieve with this request
     */
    function request() public {
    
        Chainlink.Request memory req = _buildOperatorRequest(jobId, this.fulfill.selector);
		     
        // DEFINE THE REQUEST PARAMETERS (example)
        int256 minVal = -500;
        int256 maxVal = 500;
        uint256 quantity = 5;

        req._addInt('minVal', minVal);
        req._addInt('maxVal', maxVal);
        req._addUint('quantity', quantity);
        req._add('contact', '');     // PLEASE ENTER YOUR CONTACT INFO. this allows us to notify you in the event of any emergencies related to your request (ie, bugs, downtime, etc.). example values: 'derek_linkwellnodes.io' (Discord handle) OR 'derek@linkwellnodes.io' OR '+1-617-545-4721'
        
        // Send the request to the Chainlink oracle
        bytes32 requestId = _sendOperatorRequest(req, fee);

        // Cache this request for usage later when verifying the result
        requestMap[requestId] = VRNRequest(minVal, maxVal, "", new int256[](0), true);
    }

    bytes32 public latestFulfilledRequestId;

    // Receive the result from the Chainlink oracle
    event RequestFulfilled(bytes32 requestId, int256[] randomNumbers, bytes32 hash);
    function fulfill(bytes32 requestId, int256[] memory _randomNumbers, bytes32 hash) public recordChainlinkFulfillment(requestId) {

        // Process the oracle response
        // emit RequestFulfilled(requestId, _randomNumber, hash);
        latestFulfilledRequestId = requestId;

        // DO NOT REMOVE (needed if you wish to verify randomness later on)
        // Retrieve the existing request metadata from the requestMap
        VRNRequest storage req = requestMap[requestId];
        // Perform sanity-checks
        require(req.requested, "Invalid requestId");
        require(req.hash == "", "Request already fulfilled");
        // Update the request metadata
        req.randomNumbers = _randomNumbers;
        req.hash = hash;
    }

    // Get the most recently-fulfilled random number(s)
    function getLatestRandomNumbers() public view returns (int256[] memory) {
        return getRandomNumbers(latestFulfilledRequestId);
    }

    // Retrieve fulfilled random number(s)
    function getRandomNumbers(bytes32 requestId) public view returns (int256[] memory) {
        VRNRequest memory req = requestMap[requestId];
        require(req.requested == true, "No requests for this requestId were ever made");
        require(req.hash != "", "Request for this requestId was not yet fulfilled");
        return req.randomNumbers;
    }

    // RANDOM NUMBER VERIFICATION FUNCTIONS

    // ************************
    // HOW TO USE THIS CONTRACT
    // ************************
    //
    // For more information, please visit: https://docs.linkwellnodes.io/
    //
    // GENERATING RANDOM NUMBERS:
    //
    // - LinkWell Nodes generates random numbers using a keccak256 hash of the current 32-byte secret (the 'seed'), the address of your calling contract, a unique requestId (generated by this contract and sent along with your request), and an index (the nth random number generated for this request has an index of n-1).
    // - The seed used for random number generation is updated every 6 hours at 00:00, 06:00, 12:00, and 18:00 UTC. These 6-hour periods represent 'epochs'. A seed is made public at the start of the next epoch, at which time it can be used for verification purposes.
    // 
    // 1) Using the request() function, a request is made to the LinkWell Nodes oracle for random number(s).
    // 2) LinkWell Nodes generates the prescribed random numbers off-chain, using the above-described keccak256 hashing function.
    // 3) The random number(s), as well as the keccak256 hash of the seed used to generate these numbers (the 'hash') are written to your contract via the fulfill() function.
    // 
    // VERIFYING THE RANDOM NUMBER(S):
    // 
    // - To verify the randomness of your result, you must wait until the respective seed's (secret's) epoch has ended, meaning that the seed used to generate your random number(s) is now publicly-accessible.
    // 
    // OPTION 1: (cheaper) Retrieve the seed for a given requestId using an off-chain HTTP request in your browser:
    // - 1a) Call the getHash(requestId) function, passing in the requestId in question.
    // - 1b) Retrieve the seed via your browser using the following URL:
    //       https://linkwellnodes.io/VRN-Seed.html?chain=ENTER_CHAIN_ID_HERE&hash=ENTER_HASH_HERE
    //       - Chain ID (a number) can be looked up here: https://chainlist.org/
    //       - Hash can be determined by calling getHash(requestId) function from within this contract
    //       - If successful, the seed will be present at the 'result,seed' JSON path.
    // - 1c) Finally, call the verifyResult(requestId, seed) function, manually passing in the respective requestId, and the seed retrieved above. A 'true' result means the randomness of all random number(s) present within your request was successfully verified on-chain.
    // 
    // OPTION 2: Retrieve the seed for a given requestId using an on-chain request transaction to LinkWell Nodes's oracles::
    // - 2a) Ensure that this contract is funded with the appropriate amount of LINK token, as it will be sent to our oracles in the next step, in order to cover the gas fees required for us to execute your fulfillSeedFromOracle() function on-chain.
    // - 2b) Call the requestSeedFromOracle(requestId) function, passing in the requestId in question. This step will send the required amount of LINK token along with your request, as payment.
    // - 2c) Wait several blocks for fulfillSeedFromOracle() to be called, at which point the respective seed will be written to your contract's storage, if it is yet publicly-available.
    // - 2d) Finally, call the verifyResult(requestId) function. A 'true' result means the randomness of all random number(s) present within your request was successfully verified on-chain.

    // Get the one-way hash of the secret seed used to generate the random number(s) for this requestId
    function getHash(bytes32 requestId) public view returns (bytes32) {
        VRNRequest memory req = requestMap[requestId];
        require(req.requested == true, "No requests for this requestId were ever made");
        require(req.hash != "", "Request for this requestId was not yet fulfilled");
        return req.hash;
    }

    // Verify the randomness of the given requestId (the seed must already be populated in storage via requestSeedFromOracle/fulfillSeedFromOracle) 
    function verifyResult(bytes32 requestId) public view returns (bool) {
        return verifyResult(requestId, getSeed(requestId));
    }

    // Verify the randomness of the given requestId and seed (useful if you determined the seed manually via an API call).
    // To retrieve the seed for a given hash, visit: 
    // https://linkwellnodes.io/VRN-Seed.html?chain=ENTER_CHAIN_ID_HERE&hash=ENTER_HASH_HERE
    //  Chain ID (a number) can be looked up here: https://chainlist.org/
    //  Hash can be determined by calling getHash(requestId) function from within this contract
    function verifyResult(bytes32 requestId, bytes32 seed) public view returns (bool) {

        // Retrieve the existing request metadata from the requestMap
        VRNRequest memory req = requestMap[requestId];

        // Perform sanity-checks
        require(seed != 0 && seed != 0x0000000000000000000000000000000000000000000000000000000000000000, "The provided seed doesn't exist. Possible reasons are: 1) The seed for this requestId isn't yet publicly-available, as the epoch for this seed hasn't yet ended (please wait until the next epoch and try again to retrieve the seed), 2) You attempted to verify without entering a seed. Try running requestSeed() or .");
        require(req.requested, "Invalid requestId");
        require(req.hash != "", "Request not yet fulfilled");

        // Ensure that the hash provided while fulfilling this request matches the seed used to generate this request's random number(s)
        require(req.hash == keccak256(abi.encodePacked(seed)), "RANDOMNESS COULD NOT BE VERIFIED: The hash associated with this request was NOT generated by the provided seed. Was the result tampered with?");

        // Perform local random number generation using the secret seed, and compare it to that returned by the oracle request() function
        for (uint256 i = 0; i < req.randomNumbers.length; i++) {
            require((int256(uint256(
                        keccak256(                
                            abi.encodePacked(
                                seed, 
                                address(this),
                                requestId, 
                                i))) %
                    uint256(req.maxVal - req.minVal + 1)) + req.minVal) == req.randomNumbers[i],
                    "RANDOMNESS COULD NOT BE VERIFIED: The random number(s) associated with this request could not be generated locally. Was the result tampered with?");
        }

        // Return true if we have successfully verified the randomness of all number(s) associated with this requestId
        return true;
    }

    // Send a request to the Chainlink oracle to retrieve the secret seed for the given requestId (available only after the epoch for that seed has ended)
    function requestSeedFromOracle(bytes32 requestId) public {
        Chainlink.Request memory req = _buildOperatorRequest("ac792c553fee451e87800a9c44a3abed", this.fulfillSeedFromOracle.selector);
        bytes32 hash = getHash(requestId);
        require(seedMap[hash] == 0, "Seed already retrieved for this hash. You may now use the verifyResult(requestId) function directly to verify the randomness of this requestId.");
        req._add('hash', bytes32ToString(hash));
        // Send the request to the Chainlink oracle
        _sendOperatorRequest(
            req, 
            (5 * LINK_DIVISIBILITY) / 100   // 0.05 LINK
        );
    }

    // Receive the seed for the corresponding hash from the Chainlink oracle
    event RequestSeedFulfilled(bytes32 requestId);
    function fulfillSeedFromOracle(bytes32 requestId, bytes32 hash, bytes32 seed) public recordChainlinkFulfillment(requestId) {
        // Process the oracle response
        // emit RequestSeedFulfilled(requestId);
        seedMap[hash] = seed;
    }

    // Get the seed for a specific request (must already be populated via requestSeedFromOracle/fulfillSeedFromOracle)
    function getSeed(bytes32 requestId) internal view returns (bytes32) {
        return seedMap[getHash(requestId)];
    }

    // Update oracle address
    function setOracleAddress(address _oracleAddress) public onlyOwner {
        oracleAddress = _oracleAddress;
        _setChainlinkOracle(_oracleAddress);
    }
    function getOracleAddress() public view onlyOwner returns (address) {
        return oracleAddress;
    }

    // Update jobId
    function setJobId(string memory _jobId) public onlyOwner {
        jobId = bytes32(bytes(_jobId));
    }
    function getJobId() public view onlyOwner returns (string memory) {
        return string(abi.encodePacked(jobId));
    }
    
    // Update fees
    function setFeeInJuels(uint256 _feeInJuels) public onlyOwner {
        fee = _feeInJuels;
    }
    function setFeeInHundredthsOfLink(uint256 _feeInHundredthsOfLink) public onlyOwner {
        setFeeInJuels((_feeInHundredthsOfLink * LINK_DIVISIBILITY) / 100);
    }
    function getFeeInHundredthsOfLink() public view onlyOwner returns (uint256) {
        return (fee * 100) / LINK_DIVISIBILITY;
    }

    function withdrawLink() public onlyOwner {
        LinkTokenInterface link = LinkTokenInterface(_chainlinkTokenAddress());
        require(
            link.transfer(msg.sender, link.balanceOf(address(this))),
            "Unable to transfer"
        );
    }

    // UTILITY FUNCTIONS
    function bytes32ToString(bytes32 _bytes32) internal pure returns (string memory) {
        bytes memory bytesArray = new bytes(64);
        for (uint i = 0; i < 32; i++) {
            bytes1 b = _bytes32[i];
            bytesArray[2*i] = byteToHexChar(uint8(b) >> 4);
            bytesArray[2*i + 1] = byteToHexChar(uint8(b) & 0x0f);
        }
        return string(abi.encodePacked("0x", bytesArray));
    }

    function byteToHexChar(uint8 _byte) internal pure returns (bytes1) {
        if (_byte < 10) {
            return bytes1(_byte + 48); // ASCII '0' is 48
        } else {
            return bytes1(_byte + 87); // ASCII 'a' is 97, 10 + 87 = 97
        }
    }
}
